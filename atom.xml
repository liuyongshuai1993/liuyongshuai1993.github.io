<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘小帅的博客</title>
  
  
  <link href="https://liuyongshuai1993.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuyongshuai1993.github.io/"/>
  <updated>2022-02-11T02:15:28.394Z</updated>
  <id>https://liuyongshuai1993.github.io/</id>
  
  <author>
    <name>liuyongshuai1993.github.io</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>异步执行顺序问题</title>
    <link href="https://liuyongshuai1993.github.io/2022/02/11/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://liuyongshuai1993.github.io/2022/02/11/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-11T01:15:29.000Z</published>
    <updated>2022-02-11T02:15:28.394Z</updated>
    
    <content type="html"><![CDATA[<hr><p>阅读下面代码，我们只考虑浏览器环境下的输出结果，写出它们结果打印的先后顺序，并分析出原因，小伙伴们，加油哦！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line"><span class="number">2</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BBBB&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"><span class="number">3</span> <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="number">4</span> <span class="keyword">while</span> (<span class="keyword">new</span> <span class="title class_">Date</span>() - start &lt; <span class="number">3000</span>) &#123;&#125;</span><br><span class="line"><span class="number">5</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CCCC&quot;</span>);</span><br><span class="line"><span class="number">6</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DDDD&quot;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="number">7</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="number">8</span>   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;EEEE&quot;</span>);</span><br><span class="line"><span class="number">9</span>   foo.<span class="title function_">bar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="number">10</span> &#125;)</span><br><span class="line"><span class="number">11</span> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;FFFF&quot;</span>))</span><br><span class="line"><span class="number">12</span> .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;GGGG&quot;</span>))</span><br><span class="line"><span class="number">13</span> .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HHHH&quot;</span>));</span><br><span class="line"><span class="number">14</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;IIII&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><p>浏览器下 输出结果的先后顺序是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">AAAA</span></span><br><span class="line"><span class="variable constant_">CCCC</span></span><br><span class="line"><span class="variable constant_">EEEE</span></span><br><span class="line"><span class="variable constant_">IIII</span></span><br><span class="line"><span class="variable constant_">HHHH</span></span><br><span class="line"><span class="variable constant_">BBBB</span></span><br><span class="line"><span class="variable constant_">DDDD</span></span><br></pre></td></tr></table></figure><p>答案解析：这道题考察重点是  js异步执行 宏任务 微任务。</p><p>一开始代码执行，输出<code>AAAA</code>.  1</p><p>第二行代码开启一个计时器t1(一个称呼)，这是一个异步任务且是宏任务，需要等到1秒后提交。</p><p>第四行是个while语句，需要等待3秒后才能执行下面的代码,这里有个问题，就是3秒后上一个计时器t1的提交时间已经过了，但是线程上的任务还没有执行结束，所以暂时不能打印结果，所以它排在宏任务的最前面了。</p><p>第五行又输出<code>CCCC</code></p><p>第六行又开启一个计时器t2（称呼），它提交的时间是0秒（其实每个浏览器器有默认最小时间的，暂时忽略），但是之前的t1任务还没有执行，还在等待，所以t2就排在t1的后面。（t2排在t1后面的原因是while造成的）都还需要等待，因为线程上的任务还没执行完毕。</p><p>第七行<code>new Promise</code>将执行promise函数，它参数是一个回调函数，这个回调函数内的代码是同步的，它的异步核心在于resolve和reject，同时这个异步任务在任务队列中属于微任务，是优先于宏任务执行的，(不管宏任务有多急，反正我是VIP)。所以先直接打印输出同步代码<code>EEEE</code>。第九行中的代码是个不存在的对象，这个错误要抛给reject这个状态，也就是catch去处理，但是它是异步的且是微任务，只有等到线程上的任务执行完毕，立马执行它，不管宏任务（计时器，ajax等）等待多久了。</p><p>第十四行，这是线程上的最后一个任务，打印输出    <code>IIII</code></p><p>我们先找出线程上的同步代码，将结果依次排列出来：AAAA  CCCC  EEEE IIII</p><p>然后我们再找出所有异步任务中的微任务 把结果打印出来  HHHH</p><p>最后我们再找出异步中的所有宏任务，这里t1排在前面t2排在后面（这个原因是while造成的），输出结果顺序是 BBBB DDDD</p><p>所以综上 结果是  AAAA  CCCC  EEEE  IIII  HHHH BBBB DDDD </p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;阅读下面代码，我们只考虑浏览器环境下的输出结果，写出它们结果打印的先后顺序，并分析出原因，小伙伴们，加油哦！&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>11.任务、微任务、队列和时间表</title>
    <link href="https://liuyongshuai1993.github.io/2022/02/11/%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%97%B6%E9%97%B4%E8%A1%A8/"/>
    <id>https://liuyongshuai1993.github.io/2022/02/11/%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%97%B6%E9%97%B4%E8%A1%A8/</id>
    <published>2022-02-11T01:15:29.000Z</published>
    <updated>2022-02-11T02:12:05.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务-微任务-队列"><a href="#任务-微任务-队列" class="headerlink" title="任务 微任务 队列"></a>任务 微任务 队列</h1><h4 id="微任务-宏任务"><a href="#微任务-宏任务" class="headerlink" title="微任务 宏任务"></a>微任务 宏任务</h4><p>在js中，任务可以分为同步任务和异步任务，也可以分为微任务和宏任务。同步任务属于宏任务，有了这些划分，就可以保证所有任务都有条不紊的执行下去，总的来说就是给要执行的任务定了执行规则、划分了优先级。</p><p>在总结宏任务与微任务时，我们先要知道我们哪些情况下可能会执行异步操作（未来某个时间执行任务）；然后要知道宏任务与微任务是怎么区分的，哪些属于宏任务，哪些属于微任务；最后我们要知道宏任务与微任务是通过什么规则来配合执行的。</p><ul><li><p>能存在异步执行的情况</p><ul><li>回调函数 callback</li><li>Promise&#x2F;async await</li><li>Generator 函数</li><li>事件监听</li><li>发布&#x2F;订阅</li><li>计时器</li><li>requestAnimationFrame</li><li>MutationObserver</li><li>process.nextTick</li><li>I&#x2F;O</li></ul></li><li><p>宏任务</p><ul><li>所有的同步任务</li><li>I&#x2F;O, 比如文件读写、数据库数据读写等等</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout">window.setTimeout</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setInterval">window.setInterval</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate">window.setImmediate</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame">window.requestAnimationFrame</a></li></ul></li><li><p>微任务</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise.then catch finally</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">Generator 函数</a></li><li><a href="https://es6.ruanyifeng.com/#docs/async">async await</a> 和promise是一样的，属于微任务</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a></li></ul></li><li><p>注</p><ul><li><a href="http://nodejs.cn/api/process.html#process_process_nexttick_callback_args">process.nextTick</a>(它指定的任务总是发生在所有异步任务之前)，网上几乎无一例外说这是微任务，可是只要存在这个，process.nextTick就会在所有异步任务执行之前执行</li><li>事件监听, 比如addeventlistener。宏任务待验证</li><li>发布&#x2F;订阅 宏任务待验证</li><li>有人说同步任务属于宏任务，关于这中说法我觉得不太准确，应该说同步任务的执行优先级是高于异步任务</li></ul></li><li><p>任务执行过程</p><ol><li>所有任务都在主进程上执行，异步任务会经历2个阶段 Event Table和Event Queue</li><li>同步任务在主进程排队执行，异步任务（包括宏任务和微任务）在事件队列排队等待进入主进程执行</li><li>遇到宏任务推进宏任务队列，遇到微任务推进微任务队列（宏任务队列的项一般对应一个微任务队列，有点像一个大哥带着一群小马仔，这就组成一组异步任务。如果有嵌套那就会有多个大哥小马仔）</li><li>执行宏任务，执行完宏任务，检查有没有当前层的微任务（大哥带着小马仔逐步亮相。。。）</li><li>继续执行下一个宏任务，然后执行对应层次的微任务，直到全部执行完毕（下一个大哥带着他的小马仔亮相。。。）</li></ol></li></ul><p><img src="/../img/task.jpeg" alt="task"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;任务-微任务-队列&quot;&gt;&lt;a href=&quot;#任务-微任务-队列&quot; class=&quot;headerlink&quot; title=&quot;任务 微任务 队列&quot;&gt;&lt;/a&gt;任务 微任务 队列&lt;/h1&gt;&lt;h4 id=&quot;微任务-宏任务&quot;&gt;&lt;a href=&quot;#微任务-宏任务&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微任务执行问题</title>
    <link href="https://liuyongshuai1993.github.io/2022/02/11/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://liuyongshuai1993.github.io/2022/02/11/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-11T01:15:29.000Z</published>
    <updated>2022-02-11T02:15:09.850Z</updated>
    
    <content type="html"><![CDATA[<p><strong>20200519 async await</strong></p><ol><li><p>问题1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">t1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="string">&quot;lagou&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">t1</span>()</span><br></pre></td></tr></table></figure><p>问题解析</p><p><code>await</code>是一个表达式，如果后面不是一个promise对象，就直接返回对应的值。</p><p>所以问题1可以理解为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">t1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&quot;lagou&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//lagou</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">t1</span>()</span><br></pre></td></tr></table></figure></li><li><p>问题2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">t2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">t2</span>()</span><br></pre></td></tr></table></figure><p>问题解析</p><p><code>await</code>后面如果跟一个promise对象，await将等待这个promise对象的resolve状态的值value，且将这个值返回给前面的变量，此时的promise对象的状态是一个pending状态，没有resolve状态值，所以什么也打印不了。</p></li><li><p>问题3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">t3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">t3</span>()</span><br></pre></td></tr></table></figure><p><code>await</code>后面如果跟一个promise对象，await将等待这个promise对象的resolve状态的值value，且将这个值返回给前面的变量，此时的promise对象的状态是一个resolve状态，但是它的状态值是undefined，所以打印出undefined。</p></li><li><p>问题4</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">t4</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//hello</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">t4</span>()</span><br></pre></td></tr></table></figure><p><code>await</code>后面如果跟一个promise对象，await将等待这个promise对象的resolve状态的值，且将这个值返回给前面的变量，此时的promise对象的状态是一个resolve状态，它的状态值是hello，所以打印出hello。</p></li><li><p>问题5</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">t5</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;lala&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//lala</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">t5</span>()</span><br></pre></td></tr></table></figure><p><code>await</code>后面如果跟一个promise对象，await将等待这个promise对象的resolve状态的值，且将这个值返回给前面的变量，此时的promise对象的状态是一个resolve状态，它的状态值是hello，紧接着后面又执行了一个then方法，then方法又会返回一个全新的promise对象，且这个then方法中的返回值会作为这个全新的promise中resolve的值，所以最终的结果是lala。</p></li><li><p>问题6</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">t6</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="keyword">return</span> res&#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;lagou&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">t6</span>()</span><br></pre></td></tr></table></figure><p>问题解析</p><p><code>async</code>函数执行返回一个<code>promise</code>对象,且<code>async</code>函数内部的返回值会当作这个promise对象resolve状态的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;la&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p); <span class="comment">//Promise &#123;&lt;resolved&gt;: &quot;la&quot;&#125;</span></span><br><span class="line"><span class="comment">//__proto__: Promise</span></span><br><span class="line">                <span class="comment">//[[PromiseStatus]]: &quot;resolved&quot;</span></span><br><span class="line">                <span class="comment">//[[PromiseValue]]: &quot;la&quot;</span></span><br></pre></td></tr></table></figure><p>首先考虑 <code>fn()</code> 执行返回一个promise对象，因为fn执行没有返回值，所以这个promise对象的状态resolve的值是undefined，且将这个undefined当作下一个then中回调函数的参数，所以打印的结果是undefined</p></li><li><p>问题7</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">t7</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="keyword">return</span> res&#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;lagou&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;lala&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">t7</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先考虑 <code>fn()</code> 执行返回一个promise对象，因为<code>fn()</code>执行有返回值lala，所以这个promise对象的状态resolve的值是lala，且将这个lala当作下一个then中回调函数的参数，所以打印的结果是lala。</p></li></ol><p><strong>注意细节</strong></p><ul><li><p>async函数执行的返回结果是一个promise对象，这个函数的返回值是这个promise状态值resolve的值</p></li><li><p>await后面如果不是一个promise对象，将直接返回这个值</p></li><li><p>await后面如果是一个promise对象，将会把这个promise的状态resolve的值返回出去。</p><p>以上没有考虑reject状态。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;20200519 async await&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;问题1&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>异步执行顺序问题2</title>
    <link href="https://liuyongshuai1993.github.io/2022/02/11/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%982/"/>
    <id>https://liuyongshuai1993.github.io/2022/02/11/%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%982/</id>
    <published>2022-02-11T01:15:29.000Z</published>
    <updated>2022-02-11T02:15:45.416Z</updated>
    
    <content type="html"><![CDATA[<p>阅读下面代码，我们只考虑浏览器环境下的输出结果，写出它们结果打印的先后顺序，并分析出原因，小伙伴们，加油哦！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 async function async1() &#123;</span><br><span class="line">2 console.log(&quot;AAAA&quot;);</span><br><span class="line">3 async2();</span><br><span class="line">4 console.log(&quot;BBBB&quot;);</span><br><span class="line">5 &#125;</span><br><span class="line">6 async function async2() &#123;</span><br><span class="line">7  console.log(&quot;CCCC&quot;);</span><br><span class="line">8 &#125;</span><br><span class="line">9  console.log(&quot;DDDD&quot;);</span><br><span class="line">10 setTimeout(function () &#123;</span><br><span class="line">11 console.log(&quot;FFFF&quot;);</span><br><span class="line">12 &#125;, 0);</span><br><span class="line">13 async1();</span><br><span class="line">14 new Promise(function (resolve) &#123;</span><br><span class="line">15 console.log(&quot;GGGG&quot;);</span><br><span class="line">16  resolve();</span><br><span class="line">17 &#125;).then(function () &#123;</span><br><span class="line">18  console.log(&quot;HHHH&quot;);</span><br><span class="line">19 &#125;);</span><br><span class="line">20 console.log(&quot;IIII&quot;);</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><p>浏览器下 输出结果的先后顺序是</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DDDD</span></span><br><span class="line"><span class="variable constant_">AAAA</span></span><br><span class="line"><span class="variable constant_">CCCC</span></span><br><span class="line"><span class="variable constant_">BBBB</span></span><br><span class="line"><span class="variable constant_">GGGG</span></span><br><span class="line"><span class="variable constant_">IIII</span></span><br><span class="line"><span class="variable constant_">HHHH</span></span><br><span class="line"><span class="variable constant_">FFFF</span></span><br></pre></td></tr></table></figure><p>答案解析：这道题考察重点是  js异步执行 宏任务 微任务.</p><p>这道题的坑就在于 async中如果没有await，那么它就是一个纯同步函数。</p><p>这道题的起始代码在第9行，输出<code>DDDD</code></p><p>第10行计时器开启一个异步任务t1（一个称呼），这个任务且为宏任务。</p><p>第13行函数<code>async1</code>执行，这个函数内没有await 所以它其实就是一个纯同步函数，打印输出<code>AAAA</code>,</p><p>在<code>async1</code>中执行<code>async2</code>函数，因为<code>async2</code>的内部也没有await，所以它也是个纯同步函数，打印输出<code>CCCC</code></p><p>紧接着打印输出<code>BBBB</code>。</p><p>第14行new Promise执行里面的代码也是同步的,所以打印输出<code>GGGG</code>,resolve()调用的时候开启一个异步任务t2（一个称呼），且这个任务t2是微任务，它的执行交给then()中的第一个回调函数执行，且优先级高于宏任务（t1）执行。</p><p>第20行打印输出<code>IIII</code>,此时线程上的同步任务全部执行结束。</p><p>在执行任务队列中的异步任务时，微任务优先于宏任务执行，所以先执行微任务 t2 打印输出 <code>    HHHH</code>,然后执行宏任务 t1 打印输出 <code>FFFF</code></p><p>所以综上 结果输出是 DDDD AAAA CCCC BBBB  GGGG IIII HHHH FFFF</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阅读下面代码，我们只考虑浏览器环境下的输出结果，写出它们结果打印的先后顺序，并分析出原因，小伙伴们，加油哦！&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10.this拔高</title>
    <link href="https://liuyongshuai1993.github.io/2022/02/11/this%E6%8B%94%E9%AB%98/"/>
    <id>https://liuyongshuai1993.github.io/2022/02/11/this%E6%8B%94%E9%AB%98/</id>
    <published>2022-02-11T01:12:56.000Z</published>
    <updated>2022-02-11T02:12:13.363Z</updated>
    
    <content type="html"><![CDATA[<p>只考虑浏览器环境</p><p>第一题：写出打印结果，并分析出原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">0</span>]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">obj.<span class="title function_">method</span>(fn, <span class="number">1</span>);  </span><br></pre></td></tr></table></figure><p>解析：首先，我们在全局定义了一个变量length、一个对象obj和一个函数fn，length赋值为10。接下来是fn函数，输出this.length。对象obj中，obj.length是5，obj.method是一个函数。method函数里面的形参也是一个函数，这个函数里面调用了fn函数，arguments是一个伪数组，代表method函数实际接收到的参数列表，所以arguments[0] ()就代表了调用arguments里的第一项。obj.method(fn, 1)代表的就是调用obj当中的method函数，并且传递了两个参数，fn和1。</p><p>分析完了代码的含义，我们来看输出结果。method函数当中调用的fn函数是全局当中的函数，所以this指向的是window，this.length就是10。上面说了，arguments[0] ()代表的是调用arguments里面的第一项，也就是传参进来的fn，所以这个this指向的是arguments，method函数接收的参数是两个，所以arguments.length就是2。最后的输出结果就是  10  2</p><p>第二题：写出打印结果，并分析出原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">xx</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = xx;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">a</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="title function_">a</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">x</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y.<span class="property">x</span>);</span><br></pre></td></tr></table></figure><p>解析：首先，我们在全局定义了一个变量x、一个变量y和一个函数a，函数a当中的this.x等于接收到的参数，返回this，这里要注意，返回的不是this.x，而是this。接下来我们给x赋值，值为a(5)，又给y进行赋值，值为a(6)。最后，我们输出x.x，y.x。</p><p>分析完代码的含义，我们来看输出结果。a函数传了一个参数5，那么this.x就被赋值为了5，函数a的this指向的是window，也就是window.x &#x3D; 5。上面我们说过，这个函数返回的是this，也就是this指向的window，x &#x3D; a(5)就相当于window.x &#x3D; window，此时的x被赋值为了window。下面又执行了y &#x3D; a(6)，也就是说，x的值再次发生了改变，边为了6，y则被赋值为了window。console.log(x.x)就相当于console.log(6.x)，输出的自然是undefined。console.log(y.x)，输出的相当于是console.log(window.x)，得到的值自然是6。最后输出的结果为  undefined   6</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只考虑浏览器环境&lt;/p&gt;
&lt;p&gt;第一题：写出打印结果，并分析出原因&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    
  </entry>
  
</feed>
