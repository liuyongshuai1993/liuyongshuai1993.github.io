<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>刘小帅的博客</title>
  
  
  <link href="https://liuyongshuai1993.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuyongshuai1993.github.io/"/>
  <updated>2022-02-11T01:18:02.348Z</updated>
  <id>https://liuyongshuai1993.github.io/</id>
  
  <author>
    <name>liuyongshuai1993.github.io</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>11.任务、微任务、队列和时间表.md</title>
    <link href="https://liuyongshuai1993.github.io/2022/02/11/11-%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%97%B6%E9%97%B4%E8%A1%A8-md/"/>
    <id>https://liuyongshuai1993.github.io/2022/02/11/11-%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%97%B6%E9%97%B4%E8%A1%A8-md/</id>
    <published>2022-02-11T01:15:29.000Z</published>
    <updated>2022-02-11T01:18:02.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务-微任务-队列"><a href="#任务-微任务-队列" class="headerlink" title="任务 微任务 队列"></a>任务 微任务 队列</h1><h4 id="微任务-宏任务"><a href="#微任务-宏任务" class="headerlink" title="微任务 宏任务"></a>微任务 宏任务</h4><p>在js中，任务可以分为同步任务和异步任务，也可以分为微任务和宏任务。同步任务属于宏任务，有了这些划分，就可以保证所有任务都有条不紊的执行下去，总的来说就是给要执行的任务定了执行规则、划分了优先级。</p><p>在总结宏任务与微任务时，我们先要知道我们哪些情况下可能会执行异步操作（未来某个时间执行任务）；然后要知道宏任务与微任务是怎么区分的，哪些属于宏任务，哪些属于微任务；最后我们要知道宏任务与微任务是通过什么规则来配合执行的。</p><ul><li><p>能存在异步执行的情况</p><ul><li>回调函数 callback</li><li>Promise&#x2F;async await</li><li>Generator 函数</li><li>事件监听</li><li>发布&#x2F;订阅</li><li>计时器</li><li>requestAnimationFrame</li><li>MutationObserver</li><li>process.nextTick</li><li>I&#x2F;O</li></ul></li><li><p>宏任务</p><ul><li>所有的同步任务</li><li>I&#x2F;O, 比如文件读写、数据库数据读写等等</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout">window.setTimeout</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setInterval">window.setInterval</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate">window.setImmediate</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame">window.requestAnimationFrame</a></li></ul></li><li><p>微任务</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise.then catch finally</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">Generator 函数</a></li><li><a href="https://es6.ruanyifeng.com/#docs/async">async await</a> 和promise是一样的，属于微任务</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a></li></ul></li><li><p>注</p><ul><li><a href="http://nodejs.cn/api/process.html#process_process_nexttick_callback_args">process.nextTick</a>(它指定的任务总是发生在所有异步任务之前)，网上几乎无一例外说这是微任务，可是只要存在这个，process.nextTick就会在所有异步任务执行之前执行</li><li>事件监听, 比如addeventlistener。宏任务待验证</li><li>发布&#x2F;订阅 宏任务待验证</li><li>有人说同步任务属于宏任务，关于这中说法我觉得不太准确，应该说同步任务的执行优先级是高于异步任务</li></ul></li><li><p>任务执行过程</p><ol><li>所有任务都在主进程上执行，异步任务会经历2个阶段 Event Table和Event Queue</li><li>同步任务在主进程排队执行，异步任务（包括宏任务和微任务）在事件队列排队等待进入主进程执行</li><li>遇到宏任务推进宏任务队列，遇到微任务推进微任务队列（宏任务队列的项一般对应一个微任务队列，有点像一个大哥带着一群小马仔，这就组成一组异步任务。如果有嵌套那就会有多个大哥小马仔）</li><li>执行宏任务，执行完宏任务，检查有没有当前层的微任务（大哥带着小马仔逐步亮相。。。）</li><li>继续执行下一个宏任务，然后执行对应层次的微任务，直到全部执行完毕（下一个大哥带着他的小马仔亮相。。。）</li></ol></li></ul><p><img src="/../img/task.jpeg" alt="task"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;任务-微任务-队列&quot;&gt;&lt;a href=&quot;#任务-微任务-队列&quot; class=&quot;headerlink&quot; title=&quot;任务 微任务 队列&quot;&gt;&lt;/a&gt;任务 微任务 队列&lt;/h1&gt;&lt;h4 id=&quot;微任务-宏任务&quot;&gt;&lt;a href=&quot;#微任务-宏任务&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10.this拔高-面试题.md</title>
    <link href="https://liuyongshuai1993.github.io/2022/02/11/10-this%E6%8B%94%E9%AB%98-%E9%9D%A2%E8%AF%95%E9%A2%98-md/"/>
    <id>https://liuyongshuai1993.github.io/2022/02/11/10-this%E6%8B%94%E9%AB%98-%E9%9D%A2%E8%AF%95%E9%A2%98-md/</id>
    <published>2022-02-11T01:12:56.000Z</published>
    <updated>2022-02-11T01:14:43.135Z</updated>
    
    <content type="html"><![CDATA[<p>只考虑浏览器环境</p><p>第一题：写出打印结果，并分析出原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">0</span>]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">obj.<span class="title function_">method</span>(fn, <span class="number">1</span>);  </span><br></pre></td></tr></table></figure><p>解析：首先，我们在全局定义了一个变量length、一个对象obj和一个函数fn，length赋值为10。接下来是fn函数，输出this.length。对象obj中，obj.length是5，obj.method是一个函数。method函数里面的形参也是一个函数，这个函数里面调用了fn函数，arguments是一个伪数组，代表method函数实际接收到的参数列表，所以arguments[0] ()就代表了调用arguments里的第一项。obj.method(fn, 1)代表的就是调用obj当中的method函数，并且传递了两个参数，fn和1。</p><p>分析完了代码的含义，我们来看输出结果。method函数当中调用的fn函数是全局当中的函数，所以this指向的是window，this.length就是10。上面说了，arguments[0] ()代表的是调用arguments里面的第一项，也就是传参进来的fn，所以这个this指向的是arguments，method函数接收的参数是两个，所以arguments.length就是2。最后的输出结果就是  10  2</p><p>第二题：写出打印结果，并分析出原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">xx</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = xx;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">a</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="title function_">a</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">x</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y.<span class="property">x</span>);</span><br></pre></td></tr></table></figure><p>解析：首先，我们在全局定义了一个变量x、一个变量y和一个函数a，函数a当中的this.x等于接收到的参数，返回this，这里要注意，返回的不是this.x，而是this。接下来我们给x赋值，值为a(5)，又给y进行赋值，值为a(6)。最后，我们输出x.x，y.x。</p><p>分析完代码的含义，我们来看输出结果。a函数传了一个参数5，那么this.x就被赋值为了5，函数a的this指向的是window，也就是window.x &#x3D; 5。上面我们说过，这个函数返回的是this，也就是this指向的window，x &#x3D; a(5)就相当于window.x &#x3D; window，此时的x被赋值为了window。下面又执行了y &#x3D; a(6)，也就是说，x的值再次发生了改变，边为了6，y则被赋值为了window。console.log(x.x)就相当于console.log(6.x)，输出的自然是undefined。console.log(y.x)，输出的相当于是console.log(window.x)，得到的值自然是6。最后输出的结果为  undefined   6</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只考虑浏览器环境&lt;/p&gt;
&lt;p&gt;第一题：写出打印结果，并分析出原因&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    
  </entry>
  
</feed>
